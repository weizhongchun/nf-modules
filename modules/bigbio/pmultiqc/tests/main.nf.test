nextflow_process {

    name "Test Process PMULTIQC"
    script "../main.nf"
    process "PMULTIQC"
    tag "modules"
    tag "modules_bigbio"
    tag "pmultiqc"

    config "./nextflow.config"

    test("Should generate MultiQC report") {

        when {
            def zipUrl = (params.test_data?.proteomics?.qc?.results) ?: "https://ftp.pride.ebi.ac.uk/pub/databases/pride/resources/proteomes/pmultiqc/example-projects/LFQ_PXD007683.zip"
            def zipFile = new File("test_results.zip")
            zipFile.withOutputStream { out ->
                out << new URL(zipUrl).openStream()
            }
            def resultsDir = new File("test_results")
            resultsDir.mkdirs()
            // Extract zip using Groovy's built-in zip handling
            new java.util.zip.ZipFile(zipFile).withCloseable { zip ->
                zip.entries().each { entry ->
                    if (!entry.isDirectory()) {
                        def file = new File(resultsDir, entry.name)
                        file.parentFile.mkdirs()
                        file.withOutputStream { out ->
                            out << zip.getInputStream(entry)
                        }
                    }
                }
            }
            zipFile.delete()

            process {
                """
                input[0] = [
                    [ id: 'test' ],
                    file('test_results', checkIfExists: false)
                ]
                input[1] = []
                """
            }
        }

        then {
            // Ensure the process succeeded before checking outputs to avoid NPEs
            assert process.success: "Process failed; check work dir: ${process.workDir} and logs"
            assert process.out.report[0][1] ==~ ".*\\.html"
            assert process.out.data[0] ==~ ".*_data"
            assert snapshot(process.out.versions).match("versions")
        }
    }

    test("Should generate MultiQC report with config") {

        when {
            def zipUrl = (params.test_data?.proteomics?.qc?.results) ?: "https://ftp.pride.ebi.ac.uk/pub/databases/pride/resources/proteomes/pmultiqc/example-projects/LFQ_PXD007683.zip"
            def zipFile = new File("test_results_config.zip")
            zipFile.withOutputStream { out ->
                out << new URL(zipUrl).openStream()
            }
            def resultsDir = new File("test_results_config")
            resultsDir.mkdirs()
            // Extract zip using Groovy's built-in zip handling
            new java.util.zip.ZipFile(zipFile).withCloseable { zip ->
                zip.entries().each { entry ->
                    if (!entry.isDirectory()) {
                        def file = new File(resultsDir, entry.name)
                        file.parentFile.mkdirs()
                        file.withOutputStream { out ->
                            out << zip.getInputStream(entry)
                        }
                    }
                }
            }
            zipFile.delete()

            process {
                """
                input[0] = [
                    [ id: 'test' ],
                    file('test_results_config', checkIfExists: false)
                ]
                input[1] = file('multiqc_config.yml', checkIfExists: false)
                """
            }
        }

        then {
            // Ensure the process succeeded before checking outputs to avoid NPEs
            assert process.success: "Process failed; check work dir: ${process.workDir} and logs"
            assert process.out.report[0][1] ==~ ".*\\.html"
            assert process.out.data[0] ==~ ".*_data"
            assert snapshot(process.out.versions).match("versions")
        }
    }

    test("Should generate MultiQC report for DIANN") {
        config "./nextflow.config.diann"

        when {
            def zipUrl = (params.test_data?.proteomics?.qc?.diann_results) ?: "https://ftp.pride.ebi.ac.uk/pub/databases/pride/resources/proteomes/pmultiqc/example-projects/PXD063291.zip"
            def zipFile = new File("test_diann.zip")
            zipFile.withOutputStream { out ->
                out << new URL(zipUrl).openStream()
            }
            def resultsDir = new File("test_diann_results")
            resultsDir.mkdirs()
            // Extract zip using Groovy's built-in zip handling
            new java.util.zip.ZipFile(zipFile).withCloseable { zip ->
                zip.entries().each { entry ->
                    if (!entry.isDirectory()) {
                        def file = new File(resultsDir, entry.name)
                        file.parentFile.mkdirs()
                        file.withOutputStream { out ->
                            out << zip.getInputStream(entry)
                        }
                    }
                }
            }
            zipFile.delete()

            process {
                """
                input[0] = [
                    [ id: 'DIANN_test' ],
                    file('test_diann_results', checkIfExists: false)
                ]
                input[1] = []
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert process.out.report[0][1] ==~ ".*\\.html" },
                { assert process.out.data[0] ==~ ".*_data" },
                { assert snapshot(process.out.versions).match("versions") }
            )
        }
    }

    test("Should generate MultiQC report for quantms") {
        config "./nextflow.config.quantms"

        when {
            def zipUrl = (params.test_data?.proteomics?.qc?.quantms_results) ?: "https://ftp.pride.ebi.ac.uk/pub/databases/pride/resources/proteomes/pmultiqc/example-projects/LFQ_PXD007683.zip"
            def zipFile = new File("test_quantms.zip")
            zipFile.withOutputStream { out ->
                out << new URL(zipUrl).openStream()
            }
            def resultsDir = new File("test_quantms_results")
            resultsDir.mkdirs()
            // Extract zip using Groovy's built-in zip handling
            new java.util.zip.ZipFile(zipFile).withCloseable { zip ->
                zip.entries().each { entry ->
                    if (!entry.isDirectory()) {
                        def file = new File(resultsDir, entry.name)
                        file.parentFile.mkdirs()
                        file.withOutputStream { out ->
                            out << zip.getInputStream(entry)
                        }
                    }
                }
            }
            zipFile.delete()

            process {
                """
                input[0] = [
                    [ id: 'quantms_test' ],
                    file('test_quantms_results', checkIfExists: false)
                ]
                input[1] = []
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert process.out.report[0][1] ==~ ".*\\.html" },
                { assert process.out.data[0] ==~ ".*_data" },
                { assert snapshot(process.out.versions).match("versions") }
            )
            // quantms may generate a database file
            if (process.out.quantmsdb.size() > 0) {
                assert process.out.quantmsdb[0].getName().endsWith('.db')
            }
        }
    }

    test("Should run stub mode") {

        options "-stub"

        when {
            def zipUrl = (params.test_data?.proteomics?.qc?.results) ?: "https://ftp.pride.ebi.ac.uk/pub/databases/pride/resources/proteomes/pmultiqc/example-projects/LFQ_PXD007683.zip"
            def zipFile = new File("test_stub.zip")
            zipFile.withOutputStream { out ->
                out << new URL(zipUrl).openStream()
            }
            def resultsDir = new File("test_stub_results")
            resultsDir.mkdirs()
            // Extract zip using Groovy's built-in zip handling
            new java.util.zip.ZipFile(zipFile).withCloseable { zip ->
                zip.entries().each { entry ->
                    if (!entry.isDirectory()) {
                        def file = new File(resultsDir, entry.name)
                        file.parentFile.mkdirs()
                        file.withOutputStream { out ->
                            out << zip.getInputStream(entry)
                        }
                    }
                }
            }
            zipFile.delete()

            process {
                """
                input[0] = [
                    [ id: 'test_sample' ],
                    file('test_stub_results', checkIfExists: false)
                ]
                input[1] = []
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert snapshot(process.out.report.collect { file(it[1]).getName() } +
                                process.out.data.collect { file(it).getName() } +
                                process.out.versions).match("versions_stub") }
            )
        }
    }
}
